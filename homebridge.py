
import json
from os import environ, path, makedirs, kill
import time

# Import twisted libraries
from twisted.internet.defer import inlineCallbacks, Deferred
from twisted.internet import protocol
from twisted.internet import reactor
from twisted.internet.task import LoopingCall

from yombo.core.exceptions import YomboWarning
from yombo.core.module import YomboModule
from yombo.core.log import get_logger
from yombo.utils import random_string, read_file, save_file, bytes_to_unicode
from twisted.internet.error import ProcessExitedAlready

logger = get_logger("modules.homebridge")
from yombo.modules.homebridge.web_routes import module_homebridge_routes


class HomeBridge(YomboModule):
    """
    Acts like a device - any commands it recieves, it will write to the file. Provides full
    device command responses. This module is typically used for testing and development.

    .. moduleauthor:: Mitch Schwenk <mitch-gw@yombo.net>

    :copyright: Copyright 2017 by Yombo.
    :license: LICENSE for details.
    """
    def _init_(self, **kwargs):
        self.is_master = self._Configs.get('core', 'is_master', True, False)

    @inlineCallbacks
    def _load_(self, **kwargs):
        self.homebridge_process = None
        self.is_master = self._Configs.get('core', 'is_master', True, False)
        if self.is_master is False:
            logger.warn("Homebridge module disabled, only works on the master gateway of a cluster.")
            self._Notifications.add({'title': 'Home module disabled',
                                     'message': 'The home module can only be used on a master gateway node.',
                                     'source': 'Homebridge Module',
                                     'persist': False,
                                     'priority': 'high',
                                     'always_show': True,
                                     'always_show_allow_clear': True,
                                     })
            return

        self.qrstring = None
        self.username = None
        self.pin_code = None
        self.config_file = None
        self.module_path = self._Atoms.get('yombo.path') + "/yombo/modules/homebridge/"
        try:
            self.apiauth = self._APIAuth.get('Homebridge')
            self.apiauth.enable()
            self.apiauth.rotate()
        except KeyError:
            self.apiauth = yield self._APIAuth.create(
                "Homebridge",
                description="Automatically generated by the the Homebridge module.",
            )

    @inlineCallbacks
    def _start_(self, **kwargs):
        if self.is_master is False:
            return

        configs = yield self.read_configs()
        if configs is False:
            self.generate_configs()
            yield self.save_configs()

        reactor.callLater(0.2, self.start_homebridge)

    def _stop_(self, **kwargs):
        if self.homebridge_process is not None:
            self.homebridge_process.signalProcess('KILL');

    def _webinterface_module_config_(self, **kwargs):
        """
        Add web interface routes.

        :param kwargs:
        :return:
        """
        if self.is_master is False:
            return

        return {
            'settings_link': '/module_settings/homebridge/index'
        }


    def _webinterface_add_routes_(self, **kwargs):
        """
        Add web interface routes.

        :param kwargs:
        :return:
        """
        if self.is_master is True and self._States['loader.operating_mode'] == 'run':
            return {
                'nav_side': [
                    {
                        'label1': 'Module Settings',
                        'label2': 'Homebridge',
                        'priority1': 820,  # Even with a value, 'Tools' is already defined and will be ignored.
                        'priority2': 100,
                        'icon': 'fa fa-cog fa-fw',
                        'url': '/module_settings/homebridge/index',
                        'tooltip': '',
                        'opmode': 'run',
                    },
                ],
                'routes': [
                    module_homebridge_routes,
                ],
                'configs': {
                    'settings_link': '/module_settings/homebridge/index',
                },
            }

    @inlineCallbacks
    def rotate_username(self):
        configs = yield self.read_configs()
        if configs is False:
            self.generate_configs()
        else:
            myStr = random_string(length=12, char_set='0123456789ABCDEF')
            self.username = ':'.join(myStr[i:i + 2] for i in range(0, len(myStr), 2))
            self.pin_code = "%s-%s-%s" % (
                random_string(length=3, char_set='0123456789'),
                random_string(length=2, char_set='0123456789'),
                random_string(length=3, char_set='0123456789')
            )
            self.config_file['bridge']['username'] = self.username
            self.config_file['bridge']['pin'] = self.pin_code
        yield self.save_configs()
        self.restart_homebridge()

    @inlineCallbacks
    def read_configs(self):
        try:
            content = yield read_file('%s/config.json' % self.module_path)
        except Exception as e:
            logger.info("Couldn't read existing config.json file for homebridge.")
            return False

        config_file = bytes_to_unicode(json.loads(content))

        if 'bridge' not in config_file:
            logger.warn("'bridge' section missing from homebridge config.json file.")
            return False

        if 'username' in config_file['bridge']:
            self.username = config_file['bridge']['username']
        else:
            logger.warn("'username' missing within 'bridge' section from homebridge config.json file.")
            return False

        if 'pin' in config_file['bridge']:
            self.pin_code = config_file['bridge']['pin']
        else:
            logger.warn("'pin' missing within 'bridge' section from homebridge config.json file.")
            return False

        for idx, platform in enumerate(config_file['platforms']):
            if platform['platform'] == 'Yombo':
                config_file['platforms'][idx]['apiauth'] = self.apiauth.auth_id
                break
        self.config_file = config_file

    def generate_configs(self):
        myStr = random_string(length=12, char_set='0123456789ABCDEF')
        self.username = ':'.join(myStr[i:i + 2] for i in range(0, len(myStr), 2))
        self.pin_code = "%s-%s-%s" % (
            random_string(length=3, char_set='0123456789'),
            random_string(length=2, char_set='0123456789'),
            random_string(length=3, char_set='0123456789')
        )
        self.config_file = {
            "bridge": {
                "name": "Yombo Homebridge",
                "username": self.username,
                "port": 51826,
                "pin": self.pin_code
            },
            "description": "Basic configuration for use with Yombo gateways.",
            "platforms": [
                {
                    "platform": "Yombo",
                    "name": "Yombo",
                    "host": "http://localhost:8080",
                    "apiauth": "",
                    "supported_types": ["automation", "binary_sensor", "climate", "cover", "device_tracker", "fan",
                                        "group", "input_boolean", "light", "lock", "media_player", "remote", "scene",
                                        "script", "sensor", "switch", "vacuum"],
                    "logging": True,
                    "verify_ssl": True
                }
            ]
        }

    @inlineCallbacks
    def save_configs(self):
        yield save_file('%s/config.json' % self.module_path, json.dumps(self.config_file, indent=4))

    def process_incoming_data(self, type, data):
        print("%s: %s" % (type, bytes_to_unicode(data)))
        if data.startswith(b"X-HM://"):
            items = data.split(b'\n');
            self.qrstring = bytes_to_unicode(items[0])

    def start_homebridge(self):
        YSP = YomboSpawnProcess(self)
        YSP.deferred = Deferred()
        # command = [self.module_path + "start_homebridge.sh",
        #            "-D", "-U", self.module_path, "-P", self.module_path+"homebridge-yombo/"]
        command = [self.module_path + "start_homebridge.sh", self.module_path, self.module_path+"homebridge-yombo/"]
        # self.homebridge_process = reactor.spawnProcess(YSP,
        #                                                command[0],
        #                                                command,
        #                                                env=environ,
        #                                                # path=self.module_path + "homebridge-yombo/",
        #                                                )

    def restart_homebridge(self):
        try:
            self.homebridge_process.signalProcess('KILL');
        except ProcessExitedAlready as e:
            raise YomboWarning('Homebridge process already exited. Starting anyways.')
            reactor.callLater(1, self.start_homebridge);
        reactor.callLater(1, self.start_homebridge);


class YomboSpawnProcess(protocol.ProcessProtocol):
    def __init__(self, HomeBridge):
        self.homebridge = HomeBridge  # A pointer to the homebridge module
        self.exit_code = None
        self.exit_processor = None
        self.processed_data = None

    # def connectionMade(self):
        # print("connectionMade!")
        # self.transport.closeStdin()  # tell them we're done

    def outReceived(self, data):
        self.homebridge.process_incoming_data('out', data)

    def errReceived(self, data):
        self.homebridge.process_incoming_data('err', data)

    # def inConnectionLost(self):
    #     print("inConnectionLost! stdin is closed! (we probably did it)")
    #     print("Child process id closes STDIN= %s" % self.transport.pid)

    # def outConnectionLost(self):
    #     print("outConnectionLost! The child closed their stdout!")

    # def errConnectionLost(self):
    #     print("errConnectionLost! The child closed their stderr.")

    def processExited(self, reason):
        print("processExited, status %d" % (reason.value.exitCode,))
        print(reason)

    def processEnded(self, reason):
        print("processEnded, status %d" % (reason.value.exitCode,))
        print(reason)
        self.exit_code = reason.value.exitCode
        if self.exit_processor is not None:
            print("doing exit processor: %s" % self.exit_processor)
            self.exit_processor(self)
